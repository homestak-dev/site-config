#!/bin/bash
# Generate nodes/{hostname}.yaml from PVE system info

set -e

show_help() {
    cat << 'EOF'
node-config.sh - Generate nodes/{hostname}.yaml from PVE system info

Usage:
  node-config.sh [options]
  make node-config [FORCE=1]

Options:
  --help, -h    Show this help message
  --force, -f   Overwrite existing config file

Environment Variables:
  FORCE=1       Same as --force (for make compatibility)

Description:
  Generates a nodes/*.yaml configuration file by gathering PVE information:
  - API endpoint (https://{fqdn}:8006)
  - Node name (must match PVE node name)
  - Default datastore
  - IP address from vmbr0

  Requires Proxmox VE to be installed.

Examples:
  ./scripts/node-config.sh              # Generate config (fails if exists)
  ./scripts/node-config.sh --force      # Overwrite existing config
  make node-config FORCE=1              # Via Makefile
EOF
    exit 0
}

# Parse arguments
FORCE="${FORCE:-0}"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            show_help
            ;;
        --force|-f)
            FORCE=1
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage information." >&2
            exit 1
            ;;
    esac
done

HOSTNAME=$(hostname -s)
FQDN=$(hostname -f)
OUTPUT_FILE="nodes/${HOSTNAME}.yaml"

# Check if PVE is installed
if ! command -v pvesh >/dev/null 2>&1; then
    echo "ERROR: Proxmox VE not detected (pvesh not found)." >&2
    echo "This command requires PVE to be installed." >&2
    exit 1
fi

# Check if file exists
if [ -f "$OUTPUT_FILE" ] && [ "$FORCE" != "1" ]; then
    echo "ERROR: $OUTPUT_FILE already exists. Use FORCE=1 to overwrite." >&2
    exit 1
fi

# Get IP address from vmbr0, falling back to eth0
NODE_IP=""
if command -v ip >/dev/null 2>&1; then
    # Try vmbr0 first (standard PVE bridge), then eth0 (pre-bridge setup)
    for iface in vmbr0 eth0; do
        NODE_IP=$(ip -j addr show dev "$iface" 2>/dev/null | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    for iface in data:
        for addr in iface.get('addr_info', []):
            if addr.get('family') == 'inet':
                print(addr['local'])
                break
except:
    pass
" 2>/dev/null || true)
        if [ -n "$NODE_IP" ]; then
            break
        fi
    done
fi

# Determine datastore (prefer local-zfs, fallback to local)
if command -v zpool >/dev/null 2>&1 && zpool list -H -o name 2>/dev/null | grep -q .; then
    DATASTORE="local-zfs"
else
    DATASTORE="local"
fi

# Try to get a better datastore from pvesm
if command -v pvesm >/dev/null 2>&1; then
    # Get first storage that can hold images
    detected=$(pvesm status --content images 2>/dev/null | awk 'NR>1 && $2=="active" {print $1; exit}' || true)
    if [ -n "$detected" ]; then
        DATASTORE="$detected"
    fi
fi

# Generate YAML output
# Use localhost for api_endpoint since scenarios run locally on the PVE host
cat <<EOF
# Auto-generated by: make node-config
# Node: $HOSTNAME
# Date: $(date -Iseconds)

node: $HOSTNAME
host: $HOSTNAME              # FK -> hosts/$HOSTNAME.yaml
api_endpoint: https://localhost:8006
api_token: $HOSTNAME         # FK -> secrets.api_tokens (manual setup required)
datastore: $DATASTORE
EOF

# Add IP if detected
if [ -n "$NODE_IP" ]; then
    echo "ip: $NODE_IP"
fi

# Add ssh_user comment
cat <<EOF

# SSH user for ansible access (default from site.yaml: root)
# Uncomment to override:
# ssh_user: root
EOF
